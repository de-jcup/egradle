<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<type language="gradle" name="org.gradle.model.RuleSource" version="3.0">
    <description>
 * A marker type for a class that is a collection of rules.
 * &lt;p&gt;
 * A rule source is not used like a regular Java object.
 * It is a stateless container of methods and possibly constants.
 * &lt;p&gt;
 * Please consult the “Rule based model configuration” chapter of the Gradle User Guide for general information about “rules”.
 *
 * &lt;h3&gt;Rule methods&lt;/h3&gt;
 * &lt;p&gt;
 * Each method that is annotated with one of the following is considered a rule:
 * &lt;ul&gt;
 * &lt;li&gt;{@link Model}&lt;/li&gt;
 * &lt;li&gt;{@link Defaults}&lt;/li&gt;
 * &lt;li&gt;{@link Mutate}&lt;/li&gt;
 * &lt;li&gt;{@link Finalize}&lt;/li&gt;
 * &lt;li&gt;{@link Validate}&lt;/li&gt;
 * &lt;li&gt;{@link Rules}&lt;/li&gt;
 * &lt;li&gt;{@link org.gradle.platform.base.ComponentType}&lt;/li&gt;
 * &lt;li&gt;{@link org.gradle.platform.base.ComponentBinaries}&lt;/li&gt;
 * &lt;li&gt;{@link org.gradle.platform.base.BinaryTasks}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Each annotation specifies the type of the rule, which affects when it will be executed.
 * &lt;p&gt;
 * The following constraints apply to all rule methods:
 * &lt;ul&gt;
 * &lt;li&gt;A method may only be annotated by at most one of the above annotations.&lt;/li&gt;
 * &lt;li&gt;A rule method may be {@code static} or not; it makes no difference.&lt;/li&gt;
 * &lt;li&gt;A rule method cannot be generic (i.e. cannot have type parameters).&lt;/li&gt;
 * &lt;li&gt;With the exception of {@link Model} methods, all methods must have at least one parameter.&lt;/li&gt;
 * &lt;li&gt;With the exception of {@link Model} methods, all methods must have a {@code void} return type.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * See {@link Model} for information on the significance of the return type of a {@link Model} method.
 *
 * &lt;h4&gt;Subjects and inputs&lt;/h4&gt;
 * &lt;p&gt;
 * Method rules declare the subject and any inputs as parameters to the method.
 * With the exception of {@link Model} methods, the subject of the rule is the, required, first parameter and all subsequent parameters are inputs.
 * For a non-void {@link Model} method, the subject (i.e. model element being created) is the return object.
 * For a void {@link Model} method, the subject is the first method parameter.
 * &lt;p&gt;
 * The {@link Path} annotation can be placed on any parameter (except the subject of {@link Model} rules) to indicate the model element to bind to.
 * If there is no {@link Path} annotation, a “by-type” binding will be attempted.
 * The binding scope is determined by how the rule source is applied.
 *
 * &lt;h3&gt;General class constraints&lt;/h3&gt;
 * &lt;p&gt;
 * Along with the constraints on individual rule methods by their associated annotation, the following are general constraints of rule source implementations:
 * &lt;ul&gt;
 * &lt;li&gt;Constructors are not allowed.&lt;/li&gt;
 * &lt;li&gt;Inheritance hierarchies are not allowed (i.e. all rules sources must directly extend {@link RuleSource}).&lt;/li&gt;
 * &lt;li&gt;Instance variables are not allowed.&lt;/li&gt;
 * &lt;li&gt;Non-final static variables are not allowed (i.e. constants are allowed).&lt;/li&gt;
 * &lt;li&gt;Methods cannot be overloaded.&lt;/li&gt;
 * &lt;li&gt;Implementations cannot be generic (i.e. cannot use type parameters).&lt;/li&gt;
 * &lt;/ul&gt;
 </description>
</type>
