<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<type language="gradle" name="org.gradle.model.Managed" version="3.0">
    <description>
 * A managed type is transparent to the model space, and enforces immutability at the appropriate times in the object's lifecycle.
 * &lt;p&gt;
 * Gradle generates implementations for managed types.
 * As such, managed types are declared either as interfaces or abstract classes.
 * The generated implementation integrates with the model space mechanisms, and manages mutability.
 * &lt;p&gt;
 * Managed types are mostly behaviour-less, as they are data.
 * Instances of managed types should effectively be considered value objects.
 *
 * &lt;h3&gt;Properties&lt;/h3&gt;
 * &lt;p&gt;
 * Managed types declare their structure as properties, via getter and setter methods.
 * Getter and setter methods are expected to conform to the well-known Java Bean naming conventions.
 * A read/write “name” property would be expressed via the following methods:
 * &lt;pre&gt;
 * void setName(String name);
 * String getName();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * A getter and setter must be declared for each property that is not of a managed type or of {@link ModelSet}.
 * For properties of managed types or of {@link ModelSet} the getter is mandatory and the setter is optional.
 * If no setter is provided the property is considered inherent and defaults to an "empty" instance of the type.
 * In addition to the traditional getter method, properties of type {@code boolean} (but not {@code Boolean})
 * also support a getter method which name starts with {@code is}, for example:
 *
 * &lt;pre&gt;
 * void setEnabled(boolean enabled);
 * boolean isEnabed();
 * &lt;/pre&gt;
 *
 * &lt;h4&gt;Supported property types&lt;/h4&gt;
 * &lt;p&gt;
 * The following JDK types are allowed:
 * &lt;ul&gt;
 * &lt;li&gt;{@link String}&lt;/li&gt;
 * &lt;li&gt;{@link Boolean}&lt;/li&gt;
 * &lt;li&gt;{@link Character}&lt;/li&gt;
 * &lt;li&gt;{@link Byte}&lt;/li&gt;
 * &lt;li&gt;{@link Short}&lt;/li&gt;
 * &lt;li&gt;{@link Integer}&lt;/li&gt;
 * &lt;li&gt;{@link Long}&lt;/li&gt;
 * &lt;li&gt;{@link Float}&lt;/li&gt;
 * &lt;li&gt;{@link Double}&lt;/li&gt;
 * &lt;li&gt;{@link java.math.BigInteger}&lt;/li&gt;
 * &lt;li&gt;{@link java.math.BigDecimal}&lt;/li&gt;
 * &lt;li&gt;{@link java.io.File}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * All primitive types and {@link Enum} types are also allowed.
 * &lt;p&gt;
 * Properties that are themselves of a managed type are also supported.
 * &lt;p&gt;
 * Currently, the only collection types that are supported are {@link ModelSet} and {@link ModelMap}, as well as {@link java.util.Set} or {@link java.util.List}
 * of {@link org.gradle.model.internal.manage.schema.extract.ScalarTypes scalar types}, where scalar types is either one of the supported immutable JDK types above or an enumeration.
 * &lt;p&gt;
 * Properties of any other type must have their getter annotated with {@link Unmanaged}.
 * An unmanaged property is not transparent to the model infrastructure and is guaranteed to be immutable when realized.
 *
 * &lt;h3&gt;Named types&lt;/h3&gt;
 * &lt;p&gt;
 * Managed types may implement/extend the {@link org.gradle.api.Named} interface.
 * Any managed type implementing this interface will have its {@code name} attribute populated automatically
 * based on the name of the corresponding node in the model graph.
 * &lt;p&gt;
 * The {@link ModelMap} type requires that its elements are {@link org.gradle.api.Named}.
 *
 * &lt;h3&gt;Inheritance&lt;/h3&gt;
 * &lt;p&gt;
 * Managed types can be arranged into an inheritance hierarchy.
 * Every type in the hierarchy must conform to the constraints of managed types.
 *
 * &lt;h3&gt;Calculated read-only properties&lt;/h3&gt;
 * &lt;p&gt;
 * Managed types can contain getter methods that return calculated values, based on other properties.
 * For example, a “name” property may return the concatenation of a “firstName” and “lastName” property.
 * When using Java 8 or later, such properties can be implemented as interface default methods.
 * Alternatively, the managed type can be implemented as an abstract class with the calculated property implemented as a non-abstract getter method.
 * In both cases, the implementation of the calculated property getter may not call any setter method.
 *
 * &lt;h3&gt;Abstract classes&lt;/h3&gt;
 * &lt;p&gt;
 * A managed type can be implemented as an abstract class.
 * All property getters and setters must be declared {@code abstract} (with the exception of calculated read-only properties).
 * The class cannot contain instance variables, constructors, or any methods that are not a getter or setter.
 *
 * &lt;h3&gt;Creating managed model elements&lt;/h3&gt;
 * &lt;p&gt;
 * Please see {@link Model} for information on creating model elements of managed types.
 </description>
</type>
